 Have you ever been excited to play a game only to be disappointed when it lags and studders? I've spent the past six years creating a game engine and I've been shocked at the things that can make or break performance. I'll show three simple optimizations that you can use to make your game run up to 10 times quicker. But rather than just talking about it, we're going to optimize something you'll see in nearly every game to rain. My current setup renders at 50 FPS and I'll show you how I increased it up to 400 using the first optimization. This optimization is all about triangles. You can make any kind of object out of them and a slightly every game you've played is really just a bunch of triangles moving around. I've colored the model like this so you can see each triangle. Triangles can contain any kind of data you want but storing a lot of data will hurt performance more than you might think. You don't need a sacrifice rendering quality for speed but reducing memory usage will almost always guarantee faster rendering. To show you what I mean, let's look at how our terrain is rendered. It's composed of smaller meshes and each mesh contains 128 triangles. Each triangle contains three vertices which contain position, normal and UV vectors. This adds up to 12 kilobytes per mesh and 192 megabytes for the entire scene. We want to reduce this as much as we can. The first thing we'll do is get rid of the UV coordinates. These coordinates range from 0 to 1 and our position data ranges from 0 to 8. This means we can divide the position by 8 and use that to sample textures instead. With UVs gone, that brings each mesh down to 9 kilobytes and our terrain is now rendering at 75 FPS. The next step is to get rid of some position data. If we look at the terrain from above, all the meshes look the same. The only difference between them is their height so why do we need to store the same x and z positions in each one? What we can do instead is generate the positions in the vertex shader at runtime. To do this, we use a special variable called GL vertex ID. This ID starts at 0 for the first vertex then increments for each vertex after that. These vertices follow a pattern, first moving down and then up until the right. Since this pattern repeats, we can recreate it in the shader using floor and log functions. There's a bit more to the shader that I won't get into now as my plant generation video already covers it in detail. The important thing is that we no longer need to store the x and z positions in every mesh. This boosts our FPS up to 130 and the last thing we can get rid of is the normals. Currently normals are stored as a 3D vector but since they only represent a direction, they can be converted to pitch and your angles. This means we only need to store two floats but we can compress them even further into 16 bit integers. This means they have half the precision but that's still plenty for these angles. This reduces each mesh down to 3kv and it's the smallest that we can make them without losing more precision. But there's one more way to reduce memory usage and make this run twice as fast. Currently this mesh is made out of individual triangles meaning we need to provide three vertices for each of them. We can also use triangle strips which work a bit differently. We still need to provide three vertices for the first triangle but every vertex after that builds a new triangle off the last. Both examples here use 12 vertices but the strip produces six more triangles. If we change our mesh to use 8 strips, one for each row, it reduces the amount of vertices we need down to 160. This brings us down to 20 megabytes for the full scene which is nearly 10 times less than what we started with. Our terrain is now rendering 8 times faster and there's two reasons for that. First, the memory bandwidth was the bottleneck in the initial approach. Our shaders would execute very quickly then wait around for more data to be read from memory. But by reducing our memory usage our shaders can run constantly. The second reason is the vertex shader runs fewer times. Since we change from individual triangles to strips, there are two and a half times less vertices to process. Now we can make this run even faster using the second optimization trick that I call batching. This is not unique to terrain and it's not the same as instancing. I'll explain it using ice cream. Imagine you walk into an ice cream shop with your 12 friends and you ask for an ice cream, then you ask for another ice cream, and another ice cream. I know that I want to have ice cream but this ice cream dude has no idea. The ice cream dude is our GPU and each ice cream is a mesh that we want to draw. This is painfully slow but GPUs are pretty quick so drawing 12 meshes one at a time is all right. But if you try to render 100,000 of them this way your GPU will explode. The solution is to write our 12 ice creams on a list and then hand it to the ice cream dude. He then hands us 12 ice creams and the important thing here is that we only have a talk to him once. But in return he gave us multiple things. To do this in our games we give the GPU a list of all of our meshes and ask it to draw all of them. But we also need to tell the GPU where we want each mesh to be drawn. We can do this using a shader storage buffer object which is an array in the shader that stores the positions of all of our meshes. We can select the right position for each mesh using another inbuilt variable called GL Draw ID. This ID is similar to GL vertex ID but it's unique per mesh rather than per vertex. We now have an efficient way of rendering multiple meshes using only one draw call so let's compare FPS with and without batching. So why is the FPS stayed the same? To find out let's have a look at two more metrics. The difference here is the CPU time. In the old approach the CPU spends more time sending commands to the GPU to draw every single mesh. But when we use batching the CPU and the S2Send 1 command. The reason the FPS is the same is because the GPU is a bottleneck in both scenarios. But now the CPU is free to run other code. Next we'll render more terrain. Why is this so slow? We're only rendering a billion triangles. I think I see the problem. This is where the third optimization trick is useful because it reduces the amount of triangles in this scene. Having a lot of triangles is great for detailed terrain but if the player is standing here that mountain in the distance will look the same if it has a thousand or a million triangles. Our goal is to use less triangles for distant terrain without the player noticing. Currently we're rendering small meshes all the way out into the distance. So first we'll set a cap on this and this is what we'll call our first level of detail. Then we'll render the terrain again but with each mesh scaled up twice as big. This is our second level of detail. If we repeat this four times our terrain will be a kilometer wide and only use a 160,000 triangles. If we try doing this using only one level of detail we'd have to use 8.3 million triangles. The best part about this is that each level of detail uses the same amount of triangles and takes the same amount of time to render. But when we try this in the 3D view something strange occurs. Watch what happens when more levels are rendered. Since each level is rendered in the same position the lower quality distant terrain is covering up the high quality close up terrain. If we have a look at a cross section you can see the first level of detail in the middle and the other levels extending out to the sides. There are some places where the larger level of detail cuts across the smaller level which hides our high quality terrain. To fix this most games will fade out low quality objects to closer they are but transparency is expensive on large objects like terrain. What we'll do instead is sink the terrain that's close to the player. As the player moves around new high quality terrain is generated underground and then rises to the surface. As a final optimization we'll skip rendering the meshes that are completely underground. Let's go back to our 3D view and apply sinking. Now we can see the close up high quality terrain. To show you how big our terrain is now I'll highlight each level of detail and zoom out. Since the largest level of detail sinks it feels like we're looking at a planet. Now I can't compare FPS with the last approach because I don't have enough memory to render it without multiple levels of detail but I can show the difference in size. This is the entire terrain that we're rendering now and this is a terrain we're rendering at the start. Can you see it? I'll zoom in. This tiny blue area was rendering at 50 FPS but now we're rendering 16,000 times more terrain at 5 times the FPS. As a final step we should disguise where each level of detail begins using foliage. As the camera moves around you can see where the new high quality terrain rises up. We need a lot of foliage to cover it up and this video on screen will show you how to render highly optimized plants.
